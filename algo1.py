import numpy as np

def hill_climbing(loss_fn, start_points, field_size, steps=300):
    starts = np.array(start_points, dtype=float).copy()
    paths = []

    for start in starts:
        x, y = start
        current_gpa = loss_fn(x, y)
        best_x, best_y, best_gpa = x, y, current_gpa
        path = [(x, y, current_gpa, best_x, best_y, best_gpa)]
        step_size=0.2
        for _ in range(steps):
            # --- Homework: Implement Hill Climbing ---------
            # Steps:
            # 1. Get the current state (x, y, current_gpa) from path[-1]
            # 2. Generate all 8 neighbors (using ?step_size in x and/or y)
            # 3. Evaluate each neighbor with loss_fn (to compute gpa)
            # 4. Pick the neighbor with the highest gpa
            # 5. If the best neighbor is better than the current state, move there
            # 6. Otherwise, stop the search (break out of the loop)
            # ------------------------------------------------

            # --- IMPLEMENTATION START ---
            # 1. Get the current state (x, y, current_gpa) from path[-1]
            x, y, current_gpa = path[-1][0], path[-1][1], path[-1][2]
            
            # 2. Generate all 8 neighbors (using step_size in x and/or y)
            neighbors = [
                (x + step_size, y),                # 右
                (x - step_size, y),                # 左
                (x, y + step_size),                # 上
                (x, y - step_size),                # 下
                (x + step_size, y + step_size),    # 右上
                (x + step_size, y - step_size),    # 右下
                (x - step_size, y + step_size),    # 左上
                (x - step_size, y - step_size)     # 左下
            ]
            
            # 3. Evaluate each neighbor with loss_fn (to compute gpa)
            best_neighbor_x, best_neighbor_y = x, y
            best_neighbor_gpa = current_gpa
            
            for neighbor_x, neighbor_y in neighbors:
                neighbor_gpa = loss_fn(neighbor_x, neighbor_y)
                
                # 4. Pick the neighbor with the highest gpa
                if neighbor_gpa > best_neighbor_gpa:
                    best_neighbor_x, best_neighbor_y = neighbor_x, neighbor_y
                    best_neighbor_gpa = neighbor_gpa
            
            # 5. If the best neighbor is better than the current state, move there
            if best_neighbor_gpa > current_gpa:
                x, y = best_neighbor_x, best_neighbor_y
                current_gpa = best_neighbor_gpa
            else:
                # 6. Otherwise, stop the search (break out of the loop)
                break

            # --- IMPLEMENTATION END ---

            # ------------------------------------------------
            # "path" means the whole trajectory of one ship from start to end.
            # Each entry in path should include:
            #   - current ship (x, y, gpa)
            #   - best (x, y, gpa) found so far by this ship
            #
            # You can check example_1.txt (generated by main.py) to verify if your code
            #   produces a similar format and result.
            # You can also refer to algo_example.py for a better understanding.
            # Note: best_gpa should only increase over time.
            # ------------------------------------------------
            if current_gpa > best_gpa:
                best_x, best_y, best_gpa = x, y, current_gpa
            path.append((x, y, current_gpa, best_x, best_y, best_gpa))
        paths.append(path)
    return paths