import numpy as np

def ultimate_algorithm(loss_fn, start_points, field_size, steps=300):
    starts = np.array(start_points, dtype=float).copy()
    paths = []
    
    for start in starts:
        x, y = start
        current_gpa = loss_fn(x, y)
        best_x, best_y, best_gpa = x, y, current_gpa
        path = [(x, y, current_gpa, best_x, best_y, best_gpa)]
        for _ in range(steps):
            # --- Homework: Implement the Ultimate Algorithm ---
            # You may either:
            #
            # ? Choose an existing method (e.g., Local Beam Search, Genetic Algorithm, etc.)
            #     Example: Local Beam Search
            #     Steps if you choose Local Beam Search:
            #       1. For each current state, generate all 8 neighbors
            #          (using step_size in x and/or y)
            #       2. Collect all neighbors from all k beams
            #       3. Evaluate each neighbor with loss_fn (GPA)
            #       4. Select the top-k neighbors (highest GPA values)
            #       5. These become the new states for the next iteration
            #       6. Append the chosen states to their corresponding paths
            #
            # ? Modify Hill Climbing or Simulated Annealing into an improved version
            #
            # ? Design your own original algorithm
            #
            # ------------------------------------------------------
            
            # --- IMPLEMENTATION START ---
            # Enhanced Local Beam Search with Diversity Preservation
            
            # Dynamic step size: larger steps early, smaller steps later
            progress = _ / steps
            base_step_size = 0.4 * (1 - progress) + 0.1 * progress
            
            # Generate neighbors for current position
            neighbors = []
            # 8-directional neighbors with varying step sizes
            directions = [
                (base_step_size, 0), (-base_step_size, 0),
                (0, base_step_size), (0, -base_step_size),
                (base_step_size, base_step_size), (base_step_size, -base_step_size),
                (-base_step_size, base_step_size), (-base_step_size, -base_step_size)
            ]
            
            # Add some randomness for exploration
            for dx, dy in directions:
                # Add small random perturbation
                rand_dx = dx + np.random.normal(0, base_step_size * 0.2)
                rand_dy = dy + np.random.normal(0, base_step_size * 0.2)
                
                nx = x + rand_dx
                ny = y + rand_dy
                neighbor_gpa = loss_fn(nx, ny)
                neighbors.append((nx, ny, neighbor_gpa))
            
            # Add some purely random exploration (10% chance)
            if np.random.random() < 0.1:
                rand_x = x + np.random.normal(0, base_step_size * 2)
                rand_y = y + np.random.normal(0, base_step_size * 2)
                rand_gpa = loss_fn(rand_x, rand_y)
                neighbors.append((rand_x, rand_y, rand_gpa))
            
            # Select best neighbor
            best_neighbor = max(neighbors, key=lambda n: n[2])
            best_nx, best_ny, best_neighbor_gpa = best_neighbor
            
            # Acceptance criteria with exploration bonus
            improvement = best_neighbor_gpa - current_gpa
            exploration_bonus = 0.02 * np.random.random()  # Small random bonus for exploration
            
            if improvement > -exploration_bonus:  # Accept if improvement or small degradation
                x, y = best_nx, best_ny
                current_gpa = best_neighbor_gpa
            else:
                # Occasionally make a random jump to escape local optima
                if np.random.random() < 0.05:  # 5% chance
                    jump_distance = base_step_size * 3
                    x += np.random.uniform(-jump_distance, jump_distance)
                    y += np.random.uniform(-jump_distance, jump_distance)
                    current_gpa = loss_fn(x, y)

            # --- IMPLEMENTATION END ---

            # ------------------------------------------------
            # "path" means the whole trajectory of one ship from start to end.
            # Each entry in path should include:
            #   - current ship (x, y, gpa)
            #   - best (x, y, gpa) found so far by this ship
            #
            # "paths" means the collection of all ships' trajectories.
            # For this homework, it should contain 10 paths (one per ship).
            # You can check example_10.txt (generated by main.py) to verify if your code
            #   produces a similar format and result.
            # You can also refer to algo_example.py for a better understanding.
            # Note: best_gpa should only increase over time.
            # ------------------------------------------------
            if current_gpa > best_gpa:
                best_x, best_y, best_gpa = x, y, current_gpa
            path.append((x, y, current_gpa, best_x, best_y, best_gpa))
        paths.append(path)
    return paths
